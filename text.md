sudo ./dfu-util -a 0 --dfuse-address 0x08000000:leave -D .pio/build/sipeed-longan-nano/firmware.bin

### 1.1.1 有意义的 RISC-V 代码 (1.5 分)

**先决条件：** 无。

**要求：**

1. **实现场景选择屏幕。**
   - 你需要实现一个场景选择屏幕。在 1.1.1 中，代码长度并不重要。这意味着你可以根据需要编写任意长度的代码来实现这个功能。

2. **提供至少 3 种不同的选择。**
   - 场景选择屏幕上至少需要提供三种不同的选择。虽然不同的场景可以是相同的，但总体工作量应该在一个合理的范围内。这表明你可以重复使用某些场景，以减少开发的工作量。

3. **除了 LCD_ShowString 和输入相关函数外，不调用任何其他 C 函数。**
   - 在你的 RISC-V 代码中，除了 `LCD_ShowString` 函数和与输入相关的函数之外，你不应该调用任何其他 C 函数。你可以自己在 C 语言中实现与输入相关的函数。

4. **你的 RISC-V 代码调用由 C 编写的函数。**
   - 你的 RISC-V 代码需要调用由 C 语言编写的函数。这意味着你需要将 RISC-V 代码与 C 代码进行集成，通过适当的接口调用 C 函数。

### 1.1.2 参数和返回值传递 (0.5 分)

**先决条件：** 在 1.1.1 中至少获得 1.0 分。

在实验 4 中，你已经学习了 RISC-V 的基本调用约定。现在，你需要在实际应用中使用它。

**要求：**
- 你的 RISC-V 代码需要从 C 代码接收一些参数（例如初始选择），并返回一些值给 C 代码。使用全局变量来完成这部分任务将不会获得分数。

---

### 1.1.3 操作全局变量 (0.5 分)

**先决条件：** 在 1.1.1 中至少获得 1.0 分。

**目标：**
除了参数和返回值之外，RISC-V 代码还可以通过全局变量与 C 代码进行交互。让你的 RISC-V 代码直接读取或写入一些全局变量。

**要求：**
- 你的 RISC-V 代码需要修改一些全局变量。可行的例子包括但不限于使用全局变量接收场景列表和使用全局变量返回选定的场景。

---

### 1.1.4 学习使用反汇编器 (0.5 分)

**先决条件：** 无。

**目标：**
在项目 3 中，你可能已经学会了使用性能分析工具，但你可能不知道当你用 C 语言编写代码时，编译器会生成什么样的汇编代码。然而，一个好的 C 程序员应该能够通过 C 代码预见汇编代码和 CPU 内部状态。因此，学习使用反汇编器对 C 程序员来说非常重要。

在这个项目中，你将使用反汇编器将编译器生成的二进制文件（`.o` 和 `.elf`）转换为汇编代码。

我们建议你使用 Longan 开发套件中的 `riscv-nuclei-elf-objdump`（链接有效期至 2025 年 6 月 20 日）作为反汇编器。

**要求：**
回答以下问题：

1. **选择一个 for 或 while 循环：** 在你的 C 代码中选择一个 for 或 while 循环，在汇编代码中找到它，并展示其编译结果。
   
2. **回忆分支指令中的立即数只有 1 位填充零：** 回忆一下，分支指令中的立即数只有 1 位填充零，由此我们可以推断 RISC-V 指令的长度可能不限于 4 字节。从本项目中的任何编译器生成的二进制文件中找到直接证据来支持这一论点。


---


### 1.2 基本游戏体验 (4 分)

#### 1.2.1 屏幕上有代表玩家的像素，并且玩家可以响应键盘输入移动。(1 分)

- **要求：** 在屏幕上显示一些像素来表示玩家，并确保这些像素能够根据键盘输入进行移动。例如，当玩家按下方向键时，屏幕上的玩家像素应该相应地向左、右、上或下移动。

#### 1.2.2 玩家可以射击。(1 分)

- **要求：** 实现玩家的射击功能。玩家可以通过特定的按键（如空格键）发射子弹。这里不需要考虑子弹是否具有追踪敌人的能力，即子弹可以是直线飞行的，也可以是随机方向的，只要能实现射击动作即可。

#### 1.2.3 屏幕上有代表敌人的像素，并且敌人可以移动。(1 分)

- **要求：** 在屏幕上显示一些像素来表示敌人，并确保这些像素能够进行移动。敌人的移动方式可以是简单的水平或垂直移动，也可以是更复杂的路径移动，但至少要表现出一定的动态效果。

#### 1.2.4 敌人可以射击。(1 分)

- **要求：** 实现敌人的射击功能。敌人可以定期或随机地发射子弹。需要注意的是，这里不要求玩家在被敌人子弹击中时死亡，因此你可以忽略玩家的碰撞检测（hitbox），甚至可以在屏幕上创建大量密集的子弹以增加视觉效果和挑战性。

---

### 详细解释

#### 任务目标

这部分任务主要关注于实现一个基本的游戏玩法框架，包括玩家控制、射击、敌人行为等核心元素。

1. **玩家控制：**
   - 需要在屏幕上显示玩家的像素，并实现键盘输入与玩家移动的绑定。这通常涉及到监听键盘事件，并根据按键改变玩家像素的位置。

2. **玩家射击：**
   - 实现玩家的射击功能，允许玩家通过特定按键发射子弹。子弹的飞行轨迹可以是简单的直线，也可以是其他形式，但不需要具备追踪敌人的能力。

3. **敌人行为：**
   - 在屏幕上显示敌人的像素，并实现敌人的移动。敌人的移动方式可以是简单的水平或垂直移动，也可以是更复杂的路径移动，但至少要表现出一定的动态效果。

4. **敌人射击：**
   - 实现敌人的射击功能，使敌人可以定期或随机地发射子弹。需要注意的是，这里不要求玩家在被敌人子弹击中时死亡，因此可以忽略玩家的碰撞检测，甚至可以在屏幕上创建大量密集的子弹以增加视觉效果和挑战性。

#### 实现建议

为了满足上述要求，可以采取以下步骤：

1. **玩家控制：**
   - 在屏幕上绘制玩家的像素，并监听键盘事件。当玩家按下方向键时，更新玩家像素的位置，使其在屏幕上移动。

2. **玩家射击：**
   - 实现玩家的射击功能，允许玩家通过特定按键发射子弹。可以在屏幕上绘制子弹的像素，并设置其飞行轨迹。

3. **敌人行为：**
   - 在屏幕上绘制敌人的像素，并实现敌人的移动。可以使用定时器或其他机制来控制敌人的移动速度和方向。

4. **敌人射击：**
   - 实现敌人的射击功能，使敌人可以定期或随机地发射子弹。可以在屏幕上绘制子弹的像素，并设置其飞行轨迹。由于不需要考虑玩家的碰撞检测，可以创建大量密集的子弹以增加视觉效果和挑战性。

通过以上措施，你可以实现一个基本的游戏玩法框架，满足任务的要求。


### 1.3 对硬件物理特性的基本理解 (1 分)

**先决条件：** 在 1.1.1 中至少获得 1.0 分，或者展示你的算法的正确性。

机械按钮固有地引入了噪声或不稳定性，即当你按下物理按钮时，信号可能不是连续的，可能会导致每次按下产生多个触发。解决这个问题最直接的方法是每隔固定的时间读取输入，但这种方法忽略了在一次读取后开始并在下一次读取前结束的短触发。

在这个任务中，我们要求你实现一个算法来读取按钮输入，并过滤掉噪声或其他不稳定性。具体来说，如果用户在时间 \( t \) 按下了键 \( k \)，并且这导致 \( k \) 被触发，那么在 \( t + 0.3s \) 之前 \( k \) 不能再次被触发，而其他键可以。

---

### 1.4 内存管理 (1 分)

**先决条件：** 在 1.2 中至少获得 3.0 分。

在第 4 讲中，你已经学习了 C 语言内存管理的基础知识。实验 2 和作业 3 强调了内存管理的重要性。Longan Nano 相对于其他微控制器具有相对丰富的 RAM 容量（32 KB），但与个人电脑（PC）相比仍然很小。

因此，内存安全对这个项目至关重要。确保你的实现正确管理内存，使你的 STG 在整个检查过程中不会崩溃或停止响应。

**要求：** 你的 STG 在整个检查过程中不应崩溃或停止响应。

**注意：** 我们鼓励在最终检查之前对你的实现进行严格的压力测试，以确保内存安全。

---

### 详细解释

#### 1.3 对硬件物理特性的基本理解

在这部分任务中，你需要处理机械按钮带来的噪声和不稳定性问题。当用户按下按钮时，由于机械原因，信号可能不是连续的，可能会导致多次触发。为了解决这个问题，你可以采取以下步骤：

1. **读取按钮输入并过滤噪声：**
   - 实现一个算法来读取按钮输入，并过滤掉噪声和其他不稳定性。例如，你可以使用去抖动技术来消除按钮按下时产生的瞬态信号。
   
2. **设置触发间隔：**
   - 如果用户在时间 \( t \) 按下了键 \( k \)，并且这导致 \( k \) 被触发，那么在 \( t + 0.3s \) 之前 \( k \) 不能再次被触发。这意味着在按键被触发后的 0.3 秒内，该按键将被忽略，以防止重复触发。同时，其他按键仍然可以正常工作。

通过以上措施，你可以有效地处理按钮输入中的噪声和不稳定性问题，确保系统的稳定性和可靠性。


---

#### 1.4 内存管理

在这部分任务中，你需要确保你的实现正确管理内存，避免内存泄漏和内存溢出等问题。

1. **学习 C 语言内存管理：**
   - 在第 4 讲中，你已经学习了 C 语言内存管理的基础知识，包括动态内存分配、内存释放等。确保你熟练掌握这些知识，并能够正确应用到实际项目中。
   
2. **强调内存管理的重要性：**
   - 实验 2 和作业 3 强调了内存管理的重要性。Longan Nano 的 RAM 容量虽然相对于其他微控制器较大，但与个人电脑相比仍然很小。因此，内存安全对这个项目至关重要。
   
3. **确保内存安全：**
   - 确保你的实现正确管理内存，使你的 STG 在整个检查过程中不会崩溃或停止响应。可以通过以下措施来确保内存安全：
     - 避免内存泄漏：确保所有动态分配的内存都被正确释放。
     - 避免内存溢出：确保不会访问超出数组或指针范围的内存。
     - 进行严格的测试：在最终检查之前对你的实现进行严格的测试，包括压力测试和边界测试，以确保内存安全。

通过以上措施，你可以确保你的实现正确管理内存，避免内存相关的问题，提高系统的稳定性和可靠性。

---

### (1 分) 1.5 基本性能要求

**先决条件：** 在 1.2 中至少获得 3.0 分。

**要求：** 你的屏幕不能闪烁，并且你的峰值帧率（FPS）要高于 25。在屏幕上显示你的 FPS 或者帧计算和渲染时间的总和，以便助教们知道你的峰值 FPS。

FPS 计数器可以（不是必须）连续显示从 0.12 到 0.15 秒内的平均结果，以提高可读性。

**注意：** 实验室作业 10 中的示例固件是一个闪烁的例子。短语“你的屏幕不闪烁”意味着你的屏幕没有视觉上的闪烁，或者你只更新必要的像素而不是定期调用 `LCD_Clear` 及其等效函数。

**注意：** Piazza 帖子 @166 和 @167 提供了 LCD 库的两个可选修复方案。

---

### 解释：

#### 先决条件
在开始这个任务之前，你需要确保你在前一个部分（1.2）中已经达到了至少 3.0 分的要求。

#### 屏幕不闪烁
这意味着你的屏幕在运行时不应该出现闪烁现象。闪烁通常是指屏幕内容快速地亮灭交替，这可能会导致视觉不适。为了避免这种情况，你可以采取以下措施：
- **仅更新必要像素**：不要每次都清除整个屏幕然后重新绘制所有内容。而是只更新那些确实需要改变的部分。
- **避免使用 `LCD_Clear`**：这个函数会清除整个屏幕，如果你频繁调用它，可能会导致屏幕闪烁。相反，你可以直接修改需要变化的像素。

#### 峰值帧率（FPS）
帧率（Frames Per Second, FPS）是衡量图形处理速度的一个重要指标，表示每秒钟能够渲染多少帧图像。在这个任务中，你需要确保你的程序能够达到至少 25 FPS 的峰值帧率。为了展示这一点，你可以在屏幕上实时显示当前的 FPS 数值或帧计算与渲染时间的总和。

#### 显示 FPS
为了让助教们能够清楚地看到你的程序是否满足帧率要求，你需要在屏幕上显示 FPS 或相关的时间信息。你可以选择直接显示瞬时 FPS，也可以显示一段时间内的平均 FPS（例如 0.12 到 0.15 秒内的平均值），这样可以让数值更加稳定，便于阅读。

#### 示例固件和 LCD 库修复
实验室作业 10 中提供的示例固件可能包含一些会导致屏幕闪烁的问题，你可以参考 Piazza 上的帖子 @166 和 @167，那里提供了针对 LCD 库的两个可选修复方案，可以帮助你解决这些问题，确保屏幕正常显示。

通过遵循这些要求和建议，你可以确保你的程序不仅能够满足基本的性能标准，还能提供良好的视觉体验。

---

### (2 分) 2.1 性能

**先决条件：** 在 1.5 中至少获得 1.0 分。

**要求：** 在正常游戏过程中保持最低帧率（每秒帧数，FPS）高于 30，并且支持屏幕上同时显示至少 128 颗子弹（包括玩家和敌人发射的子弹）。在屏幕上显示一个实体计数器，以便我们知道你支持多少颗子弹。

FPS 计数器和实体计数器应连续显示从 0.12 到 0.15 秒内的平均结果，以提高可读性。

在保持最低 FPS 超过 30 的情况下，你的 2.1 分数将根据以下表格计算：

| 支持的子弹数量 | 得分 |
|-----------------|------|
| ≥ 128           | 1.5  |
| ≥ 192           | 1.8  |
| ≥ 256           | 2.0  |

提示：参考实现对 LCD 库进行了定制以达到最大效率。

---

### 解释：

#### 先决条件
在开始这个任务之前，你需要确保你在前一个部分（1.5）中已经达到了至少 1.0 分的要求。

#### 最低帧率和子弹数量
为了满足性能要求，你的游戏需要在正常游戏过程中保持每秒至少 30 帧的帧率，并且能够同时处理至少 128 颗子弹。这包括玩家和敌人发射的所有子弹。为了展示这一点，你需要在屏幕上显示一个实体计数器，显示当前屏幕上的子弹数量。

#### 显示 FPS 和实体计数器
为了提高可读性，FPS 计数器和实体计数器应该显示一段时间内的平均值（例如 0.12 到 0.15 秒内的平均值），而不是瞬时值。

#### 得分计算
根据你支持的子弹数量，你的得分将在 1.5 到 2.0 之间变化。具体分数可以通过上面的表格来确定。

#### 提示
参考实现对 LCD 库进行了优化，以达到最高的效率。你可以参考这些优化方法来提高你的程序性能。

---

### (1 分) 2.2 寻的子弹

**先决条件：** 在 1.2 基本游戏体验中至少获得 3.0 分。

**要求：**

1. 玩家可以发射朝向敌人的寻的子弹。
2. Longan Nano 不支持 RISC-V 的 F 扩展指令集，但你仍然可以使用 `float` 类型，因为编译器会自动将软件浮点库插入到你的代码中。如果你在项目 4 中使用了 `float`，并且选择了某个与 `float` 相关的操作，则需要向助教展示该操作在汇编代码中的完整路径。否则，证明你在项目 4 中没有使用 `float`。

注意：在项目 4 中使用 `float`，特别是在 2.2 项中，会显著减少你的工作量，因此我们在这里添加了第二个要求来平衡工作量。

---

### 解释：

#### 先决条件
在开始这个任务之前，你需要确保你在基本游戏体验部分（1.2）中已经达到了至少 3.0 分的要求。

#### 寻的子弹
玩家应该能够发射能够自动追踪敌人的子弹。这需要一定的算法来计算子弹的运动轨迹，使其能够朝向目标移动。

#### 使用 `float`
由于 Longan Nano 不支持硬件浮点运算，但在某些情况下使用 `float` 可以简化编程。如果你在项目 4 中使用了 `float`，则需要向助教展示相关的汇编代码，以证明你正确地使用了浮点运算。如果没有使用 `float`，则需要提供相应的证明。

---

### (4 分) 2.3 扩展内容

#### (1 分) 2.3.1 实现至少 3 种形状不同的子弹。

#### (1 分) 2.3.2 实现至少 3 种轨迹不同的子弹。寻的子弹不计入此部分。

#### (1 分) 2.3.3 实现至少 3 种具有不同射击模式的敌人。

#### (1 分) 2.3.4 将 2.3.1、2.3.2 和 2.3.3 整合成一个完整的场景，包含至少 1 分钟的可玩内容。

注意：在 2.3.1、2.3.2 和 2.3.3 中，形状或轨迹 A 和 B 是不同的，当且仅当不存在任何方式通过任意手段将 A 转换为 B。

---

### 解释：

#### 扩展内容
这部分要求你扩展游戏的内容，增加多样性和趣味性。

#### 子弹形状和轨迹
你需要设计至少 3 种不同形状和 3 种不同轨迹的子弹。寻的子弹不计入轨迹不同的子弹中。

#### 敌人射击模式
你需要设计至少 3 种具有不同射击模式的敌人，使游戏更具挑战性。

#### 完整场景
最后，你需要将上述所有元素整合成一个完整的场景，确保游戏内容丰富且可玩时间不少于 1 分钟。

#### 注意事项
在设计子弹形状和轨迹时，要确保它们之间有明显的区别，不能通过简单的转换相互替代。